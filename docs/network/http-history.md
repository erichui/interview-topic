---
title: HTTP版本对比
---

## 历史

1. `HTTP/0.9`: 只有一个 `GET` 命令
2. `HTTP/1.0`: 增加了大量内容
3. `HTTP/1.1`: 进一步完善，是目前最流行的版本
4. `SPDY`: 谷歌发布的协议，主要解决 1.1 版本效率不高的问题
5. `HTTP/2`: 借鉴了 `SPDY`


## `HTTP/1.0 HTTP/1.1` 的区别

1. **缓存处理**: `HTTP/1.0`: 使用 `no-cache` `Last-Modified/If-Modified-Since`。 `HTTP/1.1` 引入更多的缓存策略：`cache-control` `E-Tag/If-None-Match` 
2. **错误状态管理**: 新增了 24 个错误状态响应码
3. **增加了几个请求首部字段**:
	- **范围请求**: 在请求首部中增加了 `range` 字段，表示请求资源的一部分，应用场景：断点续传。服务器正确处理后，会返回 `206 Partical Content` 的响应， 若无法处理改范围请求，会返回 `200 OK` 的响应以及全部资源。
	- **Host**： 主要为了解决共享 `IP` 地址的问题。在一台物理机上可以存在多个虚拟主机，他们共享同一个 `IP` 地址，但部署了多个域名，`Host` 就是用来指定域名。如果请求首部字段没有改字段会报错，`400 Bad Request`

4. **长链接**： 默认开启 `Connection：keep-alive`，即 `TCP` 链接默认不关闭，可被多个请求复用。长链接的情况下客户端如何判断响应的数据已经完成：
	- `Content-Length`: 当请求的是一个静态资源时，服务器知道响应内容的大小，响应中加入改字段，客户端据此判断响应是否完成。
	- `Transfer-Encoding: chunked`: 服务器无法预先知道大小，比如响应的内容是动态的，需要一遍产生数据一遍发给客户端。这时会用 `chunk` 模式传输，`chunk` 编码将数据一块一块的发出，最终用一个长度为 0 的 `chunk` 表明结束。
	
	> 但仍有以下问题：
	>> 1. 请求是串行的，必须等待前面的请求收到响应以后才能发送下个请求
	>> 2. 为了解决上面的问题，通常会多开几个 `TCP` 链接。但还是受浏览器的限制：同域并行请求的数量上限一般为 6-8 个，后续的会被阻塞。
	
5. **管道机制**: 在同一个 `TCP` 链接中，客户端可以同时发送多个请求。
	> 可以同时发送，但服务器必须按照顺序响应，请求并行发送，但响应还是串行的，没解决根本问题。
	> 服务器只有响应完前面的请求，才能响应后续的请求。这会导致**队头阻塞问题(head-of-line blocking)**，即前面的响应很慢，后面的必须在队列中等待

## `HTTP/1.1 HTTP/2` 的区别

1. **二进制分帧Frame**：1.1 的版本首部字段是文本，报文主体可以是文本也可以是二进制。2 的版本中首部字段和报文主体都是二进制，成为 `header frame - data frame`。帧是 `HTTP/2` 版本中最小的数据单位，每个帧会标示出该帧所属的流。
2. **首部压缩**：每次请求都要发送相同且不经常变化的首部，在请求比较多的场景下，首部字段占用了大量的流量。除了压缩首部，客户端和服务端同时维护一张首部信息表，所有字段，以及 `key-value` 的不同组合存入该表，生成一个索引号，后续只发送索引号即可。
3. **服务器推送**：服务端可以主动向客户端发送资源。常见的应用场景：客户端请求一个静态的页面，页面里面同时也包含其他的静态资源，比如：图片，样式，脚本等。在请求页面的时候，服务器可以预设还会请求页面中其他的静态资源，这个时候可以主动推送这些资源，减少请求。
4. **多路复用**：相同域名的所有请求都通过一个 `TCP` 链接并发的请求和响应。不用按照顺序对应响应，避免了**队头阻塞问题**
5. **数据流Stream**：流是存在链接中的一条虚拟通道，由一个或多个帧组成。每一个流都有一个唯一的证书 `ID` 编号，并规定，客户端发出的流都为奇数，服务端的流为偶数。